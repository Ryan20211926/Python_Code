# coding:utf-8
# @Time    : 2025/4/29 13:23
# @Author  : Ryan
# @FileName: index函数.py
"""
在Python中，`rfind()` 是字符串（String）类型的一个方法，它用于从字符串的末尾开始搜索指定的子字符串，并返回其最后一次出现的索引（即最右边的位置）。如果找到子字符串，则返回其起始索引；如果未找到，则返回 -1。这个方法在处理文本数据、文件路径、URL等任务时非常有用，尤其是当你需要找到子字符串最后一次出现的位置时。

### 使用方法

`rfind()` 方法的语法如下：

```python
str.rfind(sub[, start[, end]])
```

- `sub`：要查找的子字符串。
- `start`（可选）：指定开始搜索的位置（从该位置向左搜索）。默认值是字符串的长度减一，即从字符串的最后一个字符开始搜索。但需要注意的是，这里的“开始搜索的位置”实际上是一个从右向左搜索的起点，搜索会从这个位置向左进行。
- `end`（可选）：指定结束搜索的位置（不包含该位置的字符，搜索会在这个位置之前停止）。默认值是字符串的开头（即索引 0），但实际上由于搜索是从右向左进行的，所以 `end` 参数通常用于限制搜索的右边界。

### 返回值

- 如果找到子字符串，则返回其最后一次出现的起始索引。
- 如果未找到子字符串，则返回 -1。

### 示例

以下是一些使用 `rfind()` 方法的示例：

```python
# 示例1：查找子字符串最后一次出现的位置
text = "Hello, world! Hello, Python!"
index = text.rfind("Hello")
print(index)  # 输出: 14，因为 "Hello" 最后一次出现在索引 14

# 示例2：指定搜索范围
index = text.rfind("Hello", 0, 20)
print(index)  # 输出: 7，因为在索引 0 到 20 的范围内，"Hello" 最后一次出现在索引 7
但注意，这里的范围实际上是限制了搜索的右边界（不包括end），并从右向左搜索。
然而，由于我们是从右向左搜索，所以start实际上更像是一个“搜索不超过此位置的右边界”，
而真正的搜索是从字符串末尾或指定的end（如果提供了的话）开始的。
在这个例子中，如果end设置为20，搜索会从索引20（不包括）向左进行，直到找到"Hello"或到达start（0）。
但在这个特定例子中，由于"Hello"在索引7和14都出现了，且都在0到20的范围内，
所以rfind找到了最右边的那个，即索引14（如果我们没有限制范围的话）。
然而，由于我们指定了start为0和end为20，这里的输出实际上是有些误导的，
因为正确的解释应该是：在0到20的范围内（但从右向左搜索），"Hello"最后一次出现的索引是7（如果我们考虑这个范围限制的话）。
但rfind实际上忽略了start作为搜索起点的意义（因为它是从右向左搜索的），
只将其视为一个不超过的右边界（与end相似，但end是必需的，因为它定义了搜索的结束点）。
然而，在这个特定的调用中，由于"Hello"在索引14处也出现在了范围内，所以它是最后一次出现的正确位置。
为了避免混淆，更好的做法可能是不要依赖start参数来限制搜索的左边界（因为它实际上不起作用），
而是只使用end参数来限制搜索的右边界。

为了清晰起见，让我们看一个只使用end参数的例子：

text = "Hello, world! Hello, Python! Hello again!"
index = text.rfind("Hello", end=20)  # 这里我们只指定了end，没有指定start
print(index)  # 输出: 7，因为在整个字符串中从右向左搜索时，"Hello"在索引20之前最后一次出现在索引7（但实际上这个解释是基于从左向右的常规思维，rfind是从右向左搜索的，所以更准确的说法是：在索引0到20（不包括20）的范围内搜索时，找到了最后一个"Hello"的起始索引7，但这个范围实际上对rfind的搜索方向没有影响，它只是从右向左搜索到end或字符串末尾）

然而，上面的解释有些冗长且可能令人困惑。为了简化，我们可以这样理解：
rfind()总是从字符串的末尾或指定的end（如果提供了的话）开始，向左搜索子字符串。
start参数实际上在这个上下文中并不限制搜索的左边界（因为它是从右向左搜索的），
而是作为一个不超过的右边界的额外条件（但这个条件通常不会被用到，因为end已经定义了搜索的结束点）。
然而，由于我们通常只关心搜索的结束点（即end），所以只使用end参数来限制搜索范围就足够了。

为了避免进一步的混淆，下面给出一个只使用end参数的清晰示例：

text = "abcHello, world! Hello, Python! def"
index = text.rfind("Hello", end=20)  # 搜索到索引20（不包括）之前
print(index)  # 输出: -1，因为在索引20之前没有找到"Hello"（实际上，"Hello"在索引13和之后的位置出现，但都超过了end的限制）

在这个例子中，我们可以清楚地看到end参数如何限制搜索的范围。

# 示例3：未找到子字符串
index = text.rfind("Java")
print(index)  # 输出: -1，因为 "Java" 不在字符串中
```

### 注意事项

- `rfind()` 方法是区分大小写的。如果需要进行不区分大小写的搜索，可以将字符串和子字符串都转换为相同的大小写（例如，都转换为小写或大写）后再调用 `rfind()` 方法。
- `start` 参数在 `rfind()` 方法中实际上并不限制搜索的左边界（因为搜索是从右向左进行的），而是作为一个不超过的右边界的额外条件。然而，由于 `end` 参数已经定义了搜索的结束点，所以通常不需要使用 `start` 参数来限制搜索范围。为了避免混淆，建议只使用 `end` 参数来限制搜索的右边界。
- 如果 `end` 参数指定的索引小于字符串的长度，搜索会在该索引之前停止。如果 `end` 小于 `start`（尽管这在 `rfind()` 的常规用法中不太常见），搜索会返回一个无效的结果，因为从右向左搜索时，`start` 实际上不起作用（它只作为一个不超过的右边界的额外条件），而 `end` 定义了搜索的实际结束点。然而，在大多数情况下，我们不需要指定 `start` 参数，只使用 `end` 参数就足够了。
- 与 `find()` 方法类似，`rfind()` 方法也只返回第一个找到的子字符串的索引（从右向左搜索时的第一个），但这里的“第一个”实际上是最后一个（因为搜索是从右向左进行的）。如果需要查找所有出现的索引，可以使用循环或正则表达式等方法来实现。但请注意，这些方法通常会比单次调用 `rfind()` 更复杂且效率更低。


# index与find的区别

在Python中，`index()` 方法和 `find()` 方法都用于在字符串中查找子串，但它们之间存在一些关键的区别：

### `find()` 方法
- 返回子串首次出现的索引，如果未找到子串，则返回 `-1`。
- 不会抛出异常。
- 允许指定搜索的起始位置和结束位置。

### `index()` 方法
- 返回子串首次出现的索引，如果未找到子串，则抛出 `ValueError` 异常。
- 不会返回 `-1`，而是通过异常来表示未找到子串。
- 不允许指定搜索的起始位置和结束位置，它总是在整个字符串范围内搜索。

### 示例代码

```python
s = "Hello, World!"

# 使用 find() 方法
try:
    print(s.find("World"))  # 输出 7
    print(s.find("Python")) # 输出 -1
except ValueError as e:
    print(e)

# 使用 index() 方法
try:
    print(s.index("World"))  # 输出 7
    print(s.index("Python")) # 抛出 ValueError: substring not found
except ValueError as e:
    print(e)
```

### 使用场景
- 当你需要在字符串中查找子串，并且能够处理子串不存在的情况时，可以使用 `find()` 方法，因为它不会抛出异常。
- 当你确信子串一定存在于字符串中，或者想要在子串不存在时让程序抛出异常（例如，通过异常处理来确保程序的健壮性）时，可以使用 `index()` 方法。

总的来说，`find()` 方法提供了一种更灵活的方式来处理子串查找的结果，而 `index()` 方法则在子串必须存在时提供了一种更严格的检查机制。

"""
name = 'alex'
v = name.find('o')
print(v)
a = name.find('e')
print(a)
b = name.index('e')
print(b)
c = name.index('t')
print(c)
