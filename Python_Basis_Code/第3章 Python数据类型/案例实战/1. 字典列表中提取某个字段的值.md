将上述逻辑封装成一个通用函数可以提高代码的复用性。以下是一个封装好的函数，可以根据传入的字典列表和字段名提取字段值，并返回一个列表。

### 封装函数
```python
def extract_field_from_dicts(dict_list, field_name, default=None):
    """
    从字典列表中提取指定字段的值，并返回一个列表。

    :param dict_list: 包含字典的列表
    :param field_name: 要提取的字段名
    :param default: 如果字段不存在时的默认值（可选）
    :return: 包含提取值的列表
    """
    return [d.get(field_name, default) for d in dict_list]
```

### 使用示例
#### 示例 1：提取单个字段
```python
dict_list = [
    {"name": "Alice", "age": 25},
    {"name": "Bob", "age": 30},
    {"name": "Charlie", "age": 35}
]

# 提取字段 "name"
extracted_names = extract_field_from_dicts(dict_list, "name")
print(extracted_names)
```

#### 输出
```python
['Alice', 'Bob', 'Charlie']
```

#### 示例 2：提取字段并提供默认值
```python
# 提取字段 "city"，如果不存在则返回 "Unknown"
extracted_cities = extract_field_from_dicts(dict_list, "city", default="Unknown")
print(extracted_cities)
```

#### 输出
```python
['Unknown', 'Unknown', 'Unknown']
```

#### 示例 3：提取嵌套字段
如果需要提取嵌套字段，可以稍微修改函数以支持嵌套路径：
```python
def extract_nested_field_from_dicts(dict_list, field_path, default=None):
    """
    从字典列表中提取嵌套字段的值，并返回一个列表。

    :param dict_list: 包含字典的列表
    :param field_path: 嵌套字段的路径，以点分隔（例如 "details.age"）
    :param default: 如果字段不存在时的默认值（可选）
    :return: 包含提取值的列表
    """
    def get_nested_value(d, path):
        """递归获取嵌套字段的值"""
        fields = path.split(".")
        for field in fields:
            if isinstance(d, dict) and field in d:
                d = d[field]
            else:
                return default
        return d

    return [get_nested_value(d, field_path) for d in dict_list]
```

#### 使用示例：提取嵌套字段
```python
dict_list = [
    {"name": "Alice", "details": {"age": 25, "city": "New York"}},
    {"name": "Bob", "details": {"age": 30, "city": "Los Angeles"}},
    {"name": "Charlie", "details": {"age": 35, "city": "Chicago"}}
]

# 提取嵌套字段 "details.age"
extracted_ages = extract_nested_field_from_dicts(dict_list, "details.age")
print(extracted_ages)
```

#### 输出
```python
[25, 30, 35]
```

### 函数的优势
1. **通用性**：可以处理任意字典列表和字段路径。
2. **灵活性**：支持默认值，避免因字段缺失导致程序出错。
3. **可扩展性**：可以轻松扩展以支持更复杂的场景，例如嵌套字段的提取。

通过封装成函数，你可以更方便地在项目中复用这些逻辑，同时保持代码的清晰和简洁。